Entity Mask - Use a string of zeros as as indicator of which components are enabled for a particular entity.
 0000001000000000
&0000001000000000
 NNNNNNYNNNNNNNNN
-------^ Whichever component was enabled 7th is enabled for this entity.
In an ECS, it's common to use a bit field to represent the components that an entity has. A bit field is an
array of bits where each bit represents a component, and a value of 1 in a bit position indicates that the entity has that component.

For example, if you have three components, you could represent them with a bit field like this:

const COMPONENT_A = 0b001;
const COMPONENT_B = 0b010;
const COMPONENT_C = 0b100;
In this example, COMPONENT_A has a value of 0b001 which represents the first bit, COMPONENT_B has a value
of 0b010 which represents the second bit, and COMPONENT_C has a value of 0b100 which represents the third bit.

To check if an entity has a particular component, you can use bitwise AND to test if the corresponding bit is
set in the bit field. For example, to test if an entity has COMPONENT_A, you can do:

if ((entity.components & COMPONENT_A) === COMPONENT_A) {
  // The entity has COMPONENT_A
}
Here, the & operator performs a bitwise AND between entity.components and COMPONENT_A. If the result is equal
to COMPONENT_A, then the corresponding bit is set, indicating that the entity has the component.

Similarly, to add a component to an entity, you can use bitwise OR to set the corresponding bit in the bit field.
For example, to add COMPONENT_B to an entity, you can do:

entity.components |= COMPONENT_B;
Here, the | operator performs a bitwise OR between entity.components and COMPONENT_B, setting the corresponding bit
in the bit field.

Note that this approach requires that the number of components is known and fixed at compile time, since each
component is represented by a single bit in the bit field. If you need to support a variable number of components
at runtime, you might need to use a different data structure, such as an array or a set.


A very optimal way of keeping track of components would be to have a 1d array that contains all of the components,
in such a way that all of an entity's components are continguous, meaning I can offset by the amount of components
one entity has to get to the next one. This also means I have to keep track of the current number of entities.
Example:
components = [Entity1PosComponent,Entity1VelComponent,Entity2PosComponent,Entity2VelComponent]
currentCount = 2;
entity1 = 0..entity1.components.length; (0-1)
entity2 = entity1.components.length..entity1.components.length + entity2.components.length (2-4)
Doesn't make sense now that I've written it, check back with this one when I've had some sleep. (Dylan Falconer).
Note: look into sparse/dense array set - is this possible in JS

Does the position component NEED all those methods? They're useful but should they be somewhere else? Seems like I 
basically want a POJO object to represent them, as well as maybe a few helper methods for setting values. One to think
on.
